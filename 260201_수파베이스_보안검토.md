# Supabase 보안 검토 보고서

**프로젝트**: SellmeBuyme (학교일자리)
**검토일**: 2026-02-01
**검토 범위**: 서비스 초기 ~ 현재
**총 경고 수**: 48개

---

## 요약 (Executive Summary)

| 카테고리 | 경고 수 | 심각도 | 서비스 영향 | 당장 수정? |
|---------|--------|--------|------------|-----------|
| Function Search Path Mutable | 19 | WARN | 수정 시 함수 먹통 가능 | ❌ 나중에 |
| Extension in Public Schema | 3 | WARN | 수정 시 검색 기능 먹통 | ❌ 건들지 말기 |
| RLS Policy Always True | 22 | WARN | 수정 시 CRUD 먹통 가능 | ❌ 천천히 |
| Auth Leaked Password Protection | 1 | WARN | 소셜 로그인만 사용 중 | ✅ 해당 없음 |

### ⚠️ 중요: 이 경고들은 "보안 경고"입니다

> **서비스가 돌아가는 데는 문제없습니다.**
>
> 언제 문제가 되나요? → 악의적 사용자가 Supabase API를 직접 호출할 때
>
> 당장 터지는 건 아닙니다. **서비스 안정성이 더 중요하면, 나중에 시간 있을 때 천천히 하셔도 됩니다.**

### 핵심 위험 요소 (보안 관점)
1. **22개의 과도하게 허용적인 RLS 정책** - 데이터 무단 접근/수정/삭제 가능 (13개는 의도적 개방)
2. ~~**유출된 비밀번호 보호 비활성화**~~ - 소셜 로그인만 사용 중 (해당 없음)
3. **19개 함수의 search_path 미설정** - 스키마 조작 공격에 취약

### 🔴 실제 더 무서운 것: 섣부른 수정으로 서비스 먹통

> 보안 수정하다가 서비스가 죽으면, 보안 위협보다 더 큰 문제입니다.
>
> **원칙: 조급하게 수정하지 않습니다. 천천히, 하나씩, 롤백 준비하고.**

---

## 1. Function Search Path Mutable (19건)

### 쉬운 설명 (중학생도 이해할 수 있게)

> **비유**: 학교에서 "김철수 불러와"라고 했을 때, 어느 반 김철수인지 안 정해놓은 것과 같습니다.
>
> 데이터베이스 함수가 "user_profiles 테이블에서 데이터 가져와"라고 할 때, **어느 폴더(스키마)에 있는 테이블인지** 명확히 지정하지 않으면 문제가 생깁니다.
>
> 악의적인 사용자가 가짜 "user_profiles" 테이블을 다른 폴더에 만들어놓으면, 함수가 그 가짜 테이블을 읽을 수 있습니다. 마치 가짜 김철수가 대신 불려가는 것처럼요.

### 왜 이렇게 되었나? (추정)
Supabase에서 함수를 만들 때 기본 템플릿을 사용하면 `search_path` 설정이 빠져 있습니다. 개발 중 빠르게 함수를 만들다 보니 이 설정을 놓친 것으로 보입니다. **기능상 문제는 없지만 보안 모범 사례를 따르지 않은 것**입니다.

### 🔴 수정하면 서비스 먹통될 수 있나요?

**가능성: 낮음 ~ 중간**

```
수정 전: 함수가 암묵적으로 public 스키마를 찾아감 (작동함)
수정 후: 함수가 명시적으로 public 스키마만 봄 (보통 작동함)

문제 발생 케이스:
- 함수 내부에서 다른 스키마의 테이블을 참조하는 경우
- 함수 시그니처(파라미터 타입)가 정확히 일치하지 않는 경우
  → "function does not exist" 에러 발생
  → 해당 함수를 쓰는 모든 기능 먹통
```

### 수정 방법 (나중에 할 때)

```sql
-- 방법 1: ALTER로 기존 함수에 설정 추가 (권장)
ALTER FUNCTION public.is_admin() SET search_path = public;

-- 방법 2: CREATE OR REPLACE로 함수 재정의
-- ⚠️ 주의: 함수 시그니처가 정확히 일치해야 함
```

### 롤백 방법 (문제 생기면)

```sql
-- search_path 설정 제거 (원래대로)
ALTER FUNCTION public.is_admin() RESET search_path;
```

### 영향받는 함수 목록

| 함수명 | 용도 | 수정 위험도 |
|-------|------|-----------|
| `is_admin` | 관리자 권한 확인 | 🔴 높음 - 잘못되면 관리자 기능 전체 먹통 |
| `search_talents_with_similarity` | 인재 검색 | 🔴 높음 - 검색 먹통 |
| `search_jobs_pgroonga` | 채용공고 검색 | 🔴 높음 - 검색 먹통 |
| `search_jobs_with_similarity` | 채용공고 유사도 검색 | 🔴 높음 - 검색 먹통 |
| `get_or_create_chat_room` | 채팅방 생성/조회 | 🟡 중간 - 채팅 기능 먹통 |
| `mark_room_as_read` | 채팅방 읽음 처리 | 🟡 중간 - 채팅 기능 먹통 |
| `increment_unread_count` | 읽지않음 카운트 | 🟡 중간 - 채팅 기능 먹통 |
| `update_chat_room_last_message` | 마지막 메시지 | 🟡 중간 - 채팅 기능 먹통 |
| `update_updated_at_column` | 범용 타임스탬프 | 🟢 낮음 - 조용히 실패 |
| `update_marker_updated_at` | 마커 타임스탬프 | 🟢 낮음 - 조용히 실패 |
| 나머지 타임스탬프 함수들 | 각종 타임스탬프 | 🟢 낮음 - 조용히 실패 |

### 권장: 당장 건들지 마세요

> 이 경고는 "악의적 사용자가 스키마를 조작할 수 있으면" 위험하다는 것입니다.
>
> 하지만 Supabase에서 일반 사용자는 스키마를 만들 권한이 없습니다.
>
> **실제 공격 가능성: 매우 낮음** → 우선순위 낮춤

---

## 2. Extension in Public Schema (3건)

### 쉬운 설명

> 한국어 검색(pgroonga), 유사도 검색(pg_trgm) 같은 확장 프로그램이 "public" 폴더에 설치되어 있습니다.
>
> Supabase는 "extensions" 폴더에 두는 것을 권장하지만, 옮기면 기존 검색 기능이 깨질 수 있습니다.

### 🔴 절대 건들지 마세요

**수정하면 서비스 먹통됩니다.**

```
pgroonga → 한국어 전문 검색에 사용 중
pg_trgm → 유사도 검색에 사용 중
unaccent → 악센트 제거에 사용 중

이것들을 extensions 스키마로 옮기면:
- 기존 검색 함수들이 extension을 못 찾음
- "operator does not exist" 에러
- 검색 기능 전체 먹통
```

### 권장: 무시하세요

> 이 경고는 무시해도 됩니다.
>
> 많은 Supabase 프로젝트가 public에 extension을 두고 잘 운영하고 있습니다.
>
> **득보다 실이 큼** → 건들지 않기

---

## 3. RLS Policy Always True (22건) - ⚠️ 카테고리별 대응 필요

### 쉬운 설명 (중학생도 이해할 수 있게)

> **비유**: 학교 사물함에 자물쇠가 있지만, **모든 열쇠가 모든 자물쇠를 열 수 있는 상태**입니다.
>
> 원래 RLS(Row Level Security)는 "너는 네 데이터만 볼 수 있어"라는 규칙을 만드는 기능입니다. 예를 들어:
> - 내가 쓴 글만 수정 가능
> - 내 프로필만 삭제 가능
> - 관리자만 공지사항 작성 가능
>
> 그런데 `USING (true)`는 "**누구나 다 OK!**"라는 뜻이에요. 마치 선생님이 "모든 학생이 모든 사물함을 열어도 됨"이라고 말한 것과 같습니다.

### UI 숨김 vs RLS 보안 (꼭 이해해야 할 개념)

```
┌─────────────────────────────────────────────────────────────┐
│  UI에서 버튼 숨김 ≠ 보안                                      │
│                                                             │
│  예시: 다른 사람 인재정보의 "삭제" 버튼을 UI에서 숨겨놨어요      │
│                                                             │
│  ✅ 일반 사용자: 버튼이 없으니 삭제 못함                        │
│  ❌ 악의적 사용자: Supabase API 직접 호출해서 삭제 가능!        │
│                                                             │
│  방법: 브라우저 개발자도구 → Network 탭에서 API URL 확인        │
│       → Postman이나 curl로 직접 DELETE 요청 보내면 끝          │
│                                                             │
│  ∴ RLS가 진짜 자물쇠, UI는 그냥 커튼                           │
└─────────────────────────────────────────────────────────────┘
```

### 왜 이렇게 되었나? (추정)

개발 과정에서 이런 상황이 반복되었을 것으로 추정됩니다:

```
1. 새 기능 개발 시작
   └─ 예: "인재정보 등록 기능 만들기"

2. 코드 작성 후 테스트
   └─ 에러 발생: "new row violates row-level security policy"
   └─ 또는: "permission denied for table talents"

3. 원인 파악
   └─ RLS 정책이 INSERT를 막고 있음
   └─ auth.uid()가 null이거나 조건이 맞지 않음

4. 빠른 해결책 선택 (급할 때)
   └─ "일단 true로 열어두고 나중에 고치자"
   └─ WITH CHECK (true) 적용

5. "나중에"가 오지 않음
   └─ 기능은 잘 작동하니 잊어버림
   └─ 22개의 정책이 이렇게 쌓임
```

### 🔴 수정하면 서비스 먹통될 수 있나요?

**가능성: 높음** - 따라서 카테고리별로 신중하게 접근해야 합니다.

```
RLS 정책을 잘못 수정하면:
- INSERT가 안 됨 → 등록 기능 먹통
- SELECT가 안 됨 → 목록 조회 먹통
- UPDATE가 안 됨 → 수정 기능 먹통
- DELETE가 안 됨 → 삭제 기능 먹통
```

---

### 📊 22개 항목 카테고리 분석

#### 카테고리 A: dev_* 테이블 (13건) - ✅ 의도적 개방, 유지

> **판단**: 개발자 전용 도구로, 의도적으로 열어둔 것. 수정 불필요.

| # | 테이블 | 정책명 | 조치 |
|---|--------|--------|------|
| 1 | `dev_board_submissions` | Anyone can delete own submissions | ✅ 유지 |
| 2 | `dev_comments` | Anyone can delete own comments | ✅ 유지 |
| 3 | `dev_ideas` | Anyone can delete own ideas | ✅ 유지 |
| 4 | `dev_notices` | Authenticated users can insert | ✅ 유지 |
| 5 | `dev_notices` | Anyone can update notices | ✅ 유지 |
| 6 | `dev_notices_images` | Anyone can delete unused images | ✅ 유지 |
| 7 | `devnote_changelog` | Authenticated users can insert | ✅ 유지 |
| 8 | `devnote_documents` | Authenticated users can insert | ✅ 유지 |
| 9 | `devnote_files` | Authenticated users can insert | ✅ 유지 |
| 10 | `devnote_folders` | Authenticated users can insert | ✅ 유지 |
| 11 | `devnote_settings` | Authenticated users can insert | ✅ 유지 |
| 12 | `devnote_site_settings` | Authenticated users can insert | ✅ 유지 |
| 13 | `devnote_user_settings` | Authenticated users can insert | ✅ 유지 |

**이유**: `/note` 경로는 개발자 전용 페이지로, 일반 사용자 접근 경로가 없음. 보안 이슈 낮음.

---

#### 카테고리 B: 관리자 전용 테이블 (3건) - 🔴 수정 필요

> **판단**: 관리자(l30417305@gmail.com)만 접근해야 함. `is_admin()` 함수 활용.

| # | 테이블 | 정책명 | 현재 | 수정 후 |
|---|--------|--------|------|---------|
| 1 | `hero_banners` | Auth all hero_banners | `true` | `is_admin()` |
| 2 | `hero_banner_config` | Auth all hero_banner_config | `true` | `is_admin()` |
| 3 | `help_settings` | Allow write for authenticated | `true` | `is_admin()` |

**수정 SQL**:
```sql
-- ===== hero_banners 수정 =====
DROP POLICY IF EXISTS "Auth all hero_banners" ON hero_banners;
CREATE POLICY "Admin only hero_banners" ON hero_banners
FOR ALL TO authenticated
USING (public.is_admin())
WITH CHECK (public.is_admin());

-- ===== hero_banner_config 수정 =====
DROP POLICY IF EXISTS "Auth all hero_banner_config" ON hero_banner_config;
CREATE POLICY "Admin only hero_banner_config" ON hero_banner_config
FOR ALL TO authenticated
USING (public.is_admin())
WITH CHECK (public.is_admin());

-- ===== help_settings 수정 =====
DROP POLICY IF EXISTS "Allow write for authenticated" ON help_settings;
CREATE POLICY "Admin only help_settings" ON help_settings
FOR ALL TO authenticated
USING (public.is_admin())
WITH CHECK (public.is_admin());
```

**롤백 SQL** (문제 시 즉시 실행):
```sql
-- hero_banners 롤백
DROP POLICY IF EXISTS "Admin only hero_banners" ON hero_banners;
CREATE POLICY "Auth all hero_banners" ON hero_banners FOR ALL USING (true) WITH CHECK (true);

-- hero_banner_config 롤백
DROP POLICY IF EXISTS "Admin only hero_banner_config" ON hero_banner_config;
CREATE POLICY "Auth all hero_banner_config" ON hero_banner_config FOR ALL USING (true) WITH CHECK (true);

-- help_settings 롤백
DROP POLICY IF EXISTS "Admin only help_settings" ON help_settings;
CREATE POLICY "Allow write for authenticated" ON help_settings FOR ALL USING (true) WITH CHECK (true);
```

---

#### 카테고리 C: 사용자 상호작용 테이블 (4건) - 🟡 수정 필요

> **판단**: 로그인 사용자만, 본인 데이터만 조작 가능하도록 제한.

| # | 테이블 | 정책명 | 현재 | 수정 후 |
|---|--------|--------|------|---------|
| 1 | `marker_likes` | marker_likes_insert | `true` | `auth.uid() = user_id` |
| 2 | `marker_likes` | marker_likes_delete | `true` | `auth.uid() = user_id` |
| 3 | `instructor_comments` | instructor_comments_insert | `true` | `auth.uid() = user_id` |
| 4 | `marker_comments` | marker_comments_insert_anyone | `true` | `auth.uid() = user_id` |

**수정 SQL**:
```sql
-- ===== marker_likes INSERT 수정 =====
DROP POLICY IF EXISTS "marker_likes_insert" ON marker_likes;
CREATE POLICY "marker_likes_insert_own" ON marker_likes
FOR INSERT TO authenticated
WITH CHECK (auth.uid() = user_id);

-- ===== marker_likes DELETE 수정 =====
DROP POLICY IF EXISTS "marker_likes_delete" ON marker_likes;
CREATE POLICY "marker_likes_delete_own" ON marker_likes
FOR DELETE TO authenticated
USING (auth.uid() = user_id);

-- ===== instructor_comments INSERT 수정 =====
DROP POLICY IF EXISTS "instructor_comments_insert" ON instructor_comments;
CREATE POLICY "instructor_comments_insert_own" ON instructor_comments
FOR INSERT TO authenticated
WITH CHECK (auth.uid() = user_id);

-- ===== marker_comments INSERT 수정 =====
DROP POLICY IF EXISTS "marker_comments_insert_anyone" ON marker_comments;
CREATE POLICY "marker_comments_insert_own" ON marker_comments
FOR INSERT TO authenticated
WITH CHECK (auth.uid() = user_id);
```

**롤백 SQL**:
```sql
-- marker_likes INSERT 롤백
DROP POLICY IF EXISTS "marker_likes_insert_own" ON marker_likes;
CREATE POLICY "marker_likes_insert" ON marker_likes FOR INSERT WITH CHECK (true);

-- marker_likes DELETE 롤백
DROP POLICY IF EXISTS "marker_likes_delete_own" ON marker_likes;
CREATE POLICY "marker_likes_delete" ON marker_likes FOR DELETE USING (true);

-- instructor_comments INSERT 롤백
DROP POLICY IF EXISTS "instructor_comments_insert_own" ON instructor_comments;
CREATE POLICY "instructor_comments_insert" ON instructor_comments FOR INSERT WITH CHECK (true);

-- marker_comments INSERT 롤백
DROP POLICY IF EXISTS "marker_comments_insert_own" ON marker_comments;
CREATE POLICY "marker_comments_insert_anyone" ON marker_comments FOR INSERT WITH CHECK (true);
```

---

#### 카테고리 D: 핵심 비즈니스 테이블 (1건) - 🟡 수정 필요

> **판단**: 소셜 로그인(Google/Kakao) 사용자만 등록 가능하도록 제한.

| # | 테이블 | 정책명 | 현재 | 수정 후 |
|---|--------|--------|------|---------|
| 1 | `talents` | Anyone can insert talents | `true` | `authenticated` |

**수정 SQL**:
```sql
-- ===== talents INSERT 수정 =====
DROP POLICY IF EXISTS "Anyone can insert talents" ON talents;
CREATE POLICY "Authenticated can insert talents" ON talents
FOR INSERT TO authenticated
WITH CHECK (auth.uid() = user_id);
```

**롤백 SQL**:
```sql
-- talents INSERT 롤백
DROP POLICY IF EXISTS "Authenticated can insert talents" ON talents;
CREATE POLICY "Anyone can insert talents" ON talents FOR INSERT WITH CHECK (true);
```

---

#### 카테고리 E: 시스템/로그 테이블 (1건) - 🟢 선택적 수정

> **판단**: 크롤러 상태 로그 테이블. 관리자만 접근해도 되지만, 영향도 낮음.

| # | 테이블 | 정책명 | 현재 | 권장 |
|---|--------|--------|------|------|
| 1 | `crawler_health_results` | Anyone can insert results | `true` | 유지 또는 `is_admin()` |

**이유**: 크롤러가 익명으로 결과를 쓸 수 있어야 할 수 있음. 서비스 로직 확인 필요.

---

### 📋 수정 전 필수 확인 사항

```
┌─────────────────────────────────────────────────────────────┐
│  ⚠️ 수정 전 체크리스트                                        │
│                                                             │
│  □ 1. is_admin() 함수가 정상 작동하는지 테스트                   │
│     SELECT public.is_admin();  -- 관리자로 로그인 후 true 반환? │
│                                                             │
│  □ 2. 테이블에 user_id 컬럼이 있는지 확인                       │
│     \d marker_likes  -- user_id 컬럼 존재?                    │
│                                                             │
│  □ 3. 롤백 SQL을 메모장에 복사해두기                            │
│     → 문제 생기면 1분 안에 복구 가능                            │
│                                                             │
│  □ 4. 새벽 시간에 작업 (사용자 적을 때)                         │
│                                                             │
│  □ 5. 하나씩 적용 후 해당 기능 테스트                           │
│     → 전체 한번에 적용 금지!                                   │
└─────────────────────────────────────────────────────────────┘
```

---

### 📊 카테고리별 요약

| 카테고리 | 건수 | 조치 | 우선순위 |
|---------|-----|------|---------|
| A. dev_* 테이블 | 13 | ✅ 유지 (의도적 개방) | - |
| B. 관리자 전용 | 3 | 🔴 `is_admin()` 적용 | 높음 |
| C. 사용자 상호작용 | 4 | 🟡 `auth.uid() = user_id` 적용 | 중간 |
| D. 핵심 비즈니스 | 1 | 🟡 `authenticated` 적용 | 중간 |
| E. 시스템/로그 | 1 | 🟢 선택적 | 낮음 |
| **합계** | **22** | | |

---

## 4. Auth Leaked Password Protection (1건) - ✅ 해당 없음

### 쉬운 설명

> 비밀번호가 "123456", "password" 같이 이미 해킹당한 적 있는 비밀번호인지 체크하는 기능이 꺼져 있습니다.

### 🟢 현재 상황: 해당 없음 (소셜 로그인 전용)

```
┌─────────────────────────────────────────────────────────────┐
│  ✅ 학교일자리는 소셜 로그인(Google/Kakao)만 사용 중            │
│                                                             │
│  - 사이트 내 비밀번호 입력 UI 자체가 없음                       │
│  - Supabase에 비밀번호가 저장되지 않음                         │
│  - OAuth 토큰만 사용                                         │
│                                                             │
│  ∴ 이 경고는 무시해도 됨                                      │
└─────────────────────────────────────────────────────────────┘
```

### 참고: 나중에 이메일/비밀번호 로그인 추가할 경우

만약 소셜 로그인 외에 이메일/비밀번호 가입을 추가한다면 그때 활성화하면 됩니다.

1. Supabase Dashboard 접속
2. Authentication → Settings → Security
3. "Leaked password protection" 활성화

또는 CLI로:
```bash
supabase config set auth.enable_leaked_password_protection true
```

---

## 🔐 안전한 작업 방법 3가지

### 방법 1: 아무것도 안 하기 ✅ (가장 안전)

> 지금 경고는 "보안 경고"입니다.
>
> - 서비스가 돌아가는 데는 문제없습니다
> - 언제 문제? → 악의적 사용자가 API를 직접 호출할 때
> - 당장 터지는 건 아닙니다
>
> **결론: 서비스 안정성이 더 중요하면, 나중에 시간 있을 때 천천히 하셔도 됩니다.**

### 방법 2: 단계적 적용 ⭐ (권장)

RLS를 한번에 다 수정하지 말고, **하나씩 테스트하면서** 적용합니다.

#### 순서 (위험도 낮은 것부터)

**0단계: dev_* 테이블** (수정 안 함)
```
dev_board_submissions, dev_comments, dev_ideas 등 13개
→ 의도적 개방 상태
→ 개발자 전용이라 수정 불필요
```

**1단계: 관리자 테이블** (is_admin 적용)
```
hero_banners, hero_banner_config, help_settings
→ is_admin() 함수로 관리자만 접근
→ 일반 사용자에게 영향 없음 (어차피 관리 페이지 접근 못함)
```

**2단계: 댓글/좋아요 테이블** (auth.uid 적용)
```
instructor_comments, marker_comments, marker_likes
→ auth.uid() = user_id 조건 추가
→ 본인 데이터만 조작 가능하도록
```

**마지막: 핵심 테이블** (가장 조심)
```
talents
→ authenticated + auth.uid() = user_id
→ 인재등록 핵심 기능이라 민감함
→ 가장 마지막에, 가장 조심해서
```

### 방법 3: 새벽에 작업

```
1. SQL 작성 (migration 파일)
     ↓
2. 새벽 시간에 적용 (사용자 적을 때)
     ↓
3. 적용 직후 테스트
   - 해당 기능 동작하는지 확인
   - 안 되면 즉시 롤백
     ↓
4. 30분~1시간 모니터링
     ↓
5. 다음 테이블로
```

---

## 📜 롤백 SQL 템플릿

**적용 전에 롤백 SQL을 미리 만들어 놓으세요.**

### 예시: talents 테이블

```sql
-- ===== 적용할 SQL =====
DROP POLICY IF EXISTS "Anyone can insert talents" ON talents;
CREATE POLICY "Authenticated users can insert talents" ON talents
FOR INSERT TO authenticated
WITH CHECK (auth.uid() = user_id);

-- ===== 롤백 SQL (문제 생기면 즉시 실행) =====
DROP POLICY IF EXISTS "Authenticated users can insert talents" ON talents;
CREATE POLICY "Anyone can insert talents" ON talents
FOR INSERT
WITH CHECK (true);
```

### 예시: 함수 search_path

```sql
-- ===== 적용할 SQL =====
ALTER FUNCTION public.is_admin() SET search_path = public;

-- ===== 롤백 SQL =====
ALTER FUNCTION public.is_admin() RESET search_path;
```

**문제 생기면 롤백 SQL 복붙 → 실행 → 1분 안에 복구**

---

## 조치 우선순위 (현실적인 버전)

### ✅ 해당 없음 (소셜 로그인 사용)
- [x] ~~Auth Leaked Password Protection~~ → 소셜 로그인만 사용 중이라 해당 없음

### 🟢 의도적 개방 - 수정 불필요 (13건)
- [x] dev_* 테이블들 (13개) → 개발자 전용, 의도적 개방 상태 유지

### 🟡 여유 있을 때 수정 (8건)
- [ ] 관리자 테이블 (3개): `hero_banners`, `hero_banner_config`, `help_settings`
  - `is_admin()` 함수로 관리자만 접근하도록 수정
- [ ] 사용자 상호작용 테이블 (4개): `marker_likes`, `instructor_comments`, `marker_comments`
  - `auth.uid() = user_id` 조건으로 본인 데이터만 조작
- [ ] 핵심 비즈니스 테이블 (1개): `talents`
  - `authenticated` + `auth.uid() = user_id` 조건

### ⏳ 나중에 (Function search_path)
- [ ] 타임스탬프 함수들 search_path 설정 (영향 적음)
- [ ] 검색 함수들 search_path 설정 (위험도 높음 - 신중히)
- [ ] 채팅 함수들 search_path 설정 (위험도 높음 - 신중히)

### ❌ 건들지 말기
- [x] ~~Extension 스키마 마이그레이션~~ → 검색 기능 먹통 위험

---

## 부록: SQL 마이그레이션 스크립트 (참고용)

> ⚠️ **주의**: 아래 SQL은 참고용입니다. 실행 전에 반드시:
> 1. 롤백 SQL 준비
> 2. 새벽 시간에 작업
> 3. 하나씩 실행 후 테스트

### A. 함수 search_path 일괄 수정

```sql
-- 파일: supabase/migrations/20260201_fix_function_search_paths.sql
-- ⚠️ 한 번에 다 하지 말고 하나씩!

-- 타임스탬프 함수들 (위험도 낮음, 먼저 해볼 것)
ALTER FUNCTION public.update_updated_at_column() SET search_path = public;
ALTER FUNCTION public.update_marker_updated_at() SET search_path = public;
-- ... 나머지는 테스트 후 순차 적용

-- 검색 함수들 (위험도 높음, 나중에)
-- ALTER FUNCTION public.search_talents_with_similarity(text) SET search_path = public;
-- ALTER FUNCTION public.search_jobs_pgroonga(text) SET search_path = public;

-- is_admin (가장 위험, 가장 마지막에)
-- ALTER FUNCTION public.is_admin() SET search_path = public;
```

### B. RLS 정책 수정 (카테고리별)

```sql
-- 파일: supabase/migrations/20260201_fix_rls_policies.sql
-- ⚠️ 롤백 SQL 반드시 준비해두고 실행
-- ⚠️ 한 번에 다 하지 말고 카테고리별로 하나씩!

-- ===== 1단계: 관리자 테이블 (is_admin 적용) =====
-- hero_banners
DROP POLICY IF EXISTS "Auth all hero_banners" ON hero_banners;
CREATE POLICY "Admin only hero_banners" ON hero_banners
FOR ALL TO authenticated
USING (public.is_admin())
WITH CHECK (public.is_admin());

-- hero_banner_config
DROP POLICY IF EXISTS "Auth all hero_banner_config" ON hero_banner_config;
CREATE POLICY "Admin only hero_banner_config" ON hero_banner_config
FOR ALL TO authenticated
USING (public.is_admin())
WITH CHECK (public.is_admin());

-- help_settings
DROP POLICY IF EXISTS "Allow write for authenticated" ON help_settings;
CREATE POLICY "Admin only help_settings" ON help_settings
FOR ALL TO authenticated
USING (public.is_admin())
WITH CHECK (public.is_admin());

-- ===== 2단계: 사용자 상호작용 테이블 (auth.uid 적용) =====
-- marker_likes INSERT
DROP POLICY IF EXISTS "marker_likes_insert" ON marker_likes;
CREATE POLICY "marker_likes_insert_own" ON marker_likes
FOR INSERT TO authenticated
WITH CHECK (auth.uid() = user_id);

-- marker_likes DELETE
DROP POLICY IF EXISTS "marker_likes_delete" ON marker_likes;
CREATE POLICY "marker_likes_delete_own" ON marker_likes
FOR DELETE TO authenticated
USING (auth.uid() = user_id);

-- ===== 3단계: 핵심 비즈니스 테이블 (가장 마지막에) =====
-- talents (위험도 높음)
-- DROP POLICY IF EXISTS "Anyone can insert talents" ON talents;
-- CREATE POLICY "Authenticated can insert talents" ON talents
-- FOR INSERT TO authenticated
-- WITH CHECK (auth.uid() = user_id);
```

---

## 참고 자료

- [Supabase Database Linter 문서](https://supabase.com/docs/guides/database/database-linter)
- [Function Search Path Mutable](https://supabase.com/docs/guides/database/database-linter?lint=0011_function_search_path_mutable)
- [Extension in Public](https://supabase.com/docs/guides/database/database-linter?lint=0014_extension_in_public)
- [RLS Policy Always True](https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy)
- [Password Security](https://supabase.com/docs/guides/auth/password-security)

---

## 결론

> **RLS 경고는 "빨간불"이지만 당장 터지는 건 아닙니다.**
>
> **서비스 먹통되는 게 더 무섭습니다.**
>
> 조급하게 하지 마시고, 천천히 하셔도 됩니다.
>
> 원하실 때 하나씩 함께 작업해 드릴 수 있습니다. 롤백 SQL까지 같이 만들어서 안전하게 진행하겠습니다.

---

**작성자**: Claude AI
**검토 필요**: 개발팀 리드
**다음 검토 예정**: 2026-03-01
