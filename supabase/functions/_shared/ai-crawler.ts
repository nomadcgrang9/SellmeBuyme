// Minimal, stable AI crawler generator with basic HTML heuristics.
export async function generateCrawlerCode(boardName: string, boardUrl: string): Promise<string> {
  const fnSuffix = (boardName || 'Crawler')
    .replace(/\s+/g, '')
    .replace(/[^a-zA-Z0-9]/g, '') || 'Crawler'

  const timestamp = new Date().toISOString()

  const lines: string[] = []
  lines.push('/**')
  lines.push(' * ' + boardName + ' crawler (AI minimal + heuristics + pagination)')
  lines.push(' * Generated at ' + timestamp)
  lines.push(' */')
  lines.push('')
  lines.push('export async function crawl' + fnSuffix + '(page, config) {')
  lines.push("  console.log('[INFO] crawl start: ' + (config.name || 'board'))")
  lines.push('  const jobs = []')
  lines.push('  const seen = new Set()')
  lines.push('  const maxItems = Math.max(1, Number(config.maxItems) || 20)')
  lines.push('  const maxPages = Math.max(1, Number(config.maxPages) || 1)')
  lines.push("  const target = config.url ?? '" + boardUrl.replace(/'/g, "\\'") + "'")
  lines.push("  await page.goto(target, { waitUntil: 'domcontentloaded', timeout: 30000 })")
  lines.push('  await page.waitForTimeout(1500)')
  lines.push('')
  lines.push('  const candidates = [')
  lines.push("    'table tbody tr',")
  lines.push("    '.board-list tbody tr',")
  lines.push("    '.tbl_list tbody tr',")
  lines.push("    'table tr',")
  lines.push("    'ul li',")
  lines.push("    '.list-item',")
  lines.push("    '.card',")
  lines.push("    '.card-item',")
  lines.push("    '.row-item',")
  lines.push("    'li.list-item',")
  lines.push("    'div.post',")
  lines.push('  ]')
  lines.push('')
  lines.push('  const titleSelectors = [')
  lines.push("    'a.subject',")
  lines.push("    '.subject a',")
  lines.push("    '.subject .title',")
  lines.push("    '.title a',")
  lines.push("    '.title .subject',")
  lines.push("    'a.title',")
  lines.push("    '.tit a',")
  lines.push("    '.name a',")
  lines.push("    '.board-title a',")
  lines.push("    '.list-title',")
  lines.push("    '.tit',")
  lines.push("    '.title',")
  lines.push("    'a[href]',")
  lines.push('  ]')
  lines.push('')
  lines.push('  const linkSelectors = [')
  lines.push("    'a.subject',")
  lines.push("    '.subject a',")
  lines.push("    '.title a',")
  lines.push("    'a.title',")
  lines.push("    '.tit a',")
  lines.push("    '.name a',")
  lines.push("    '.board-title a',")
  lines.push("    'a[href]',")
  lines.push('  ]')
  lines.push('')
  lines.push('  const dateSelectors = [')
  lines.push("    'td:nth-of-type(3)',")
  lines.push("    '.date',")
  lines.push("    '.reg-date',")
  lines.push("    '.day',")
  lines.push('  ]')
  lines.push('')
  lines.push('  const attachmentSelectors = [')
  lines.push("    'a[href*=" + '"download"' + "]',")
  lines.push("    'a[href*=" + '"attach"' + "]',")
  lines.push("    'a[href*=" + '"file"' + "]',")
  lines.push('  ]')
  lines.push('')
  lines.push('  const paginationSelectors = [')
  lines.push("    '.pagination a.next',")
  lines.push("    '.paginate a.next',")
  lines.push("    'a[rel=\"next\"]',")
  lines.push("    'a.next',")
  lines.push("    'button.next',")
  lines.push('  ]')
  lines.push('')
  lines.push('  async function firstMatchingText(row, selectors) {')
  lines.push('    for (const selector of selectors) {')
  lines.push('      const locator = row.locator(selector).first()')
  lines.push('      if (await locator.count()) {')
  lines.push('        const text = (await locator.textContent())?.trim()')
  lines.push('        if (text) return { value: text, selector }')
  lines.push('      }')
  lines.push('    }')
  lines.push('    return { value: null, selector: null }')
  lines.push('  }')
  lines.push('')
  lines.push('  async function firstMatchingHref(row, selectors) {')
  lines.push('    for (const selector of selectors) {')
  lines.push('      const locator = row.locator(selector).first()')
  lines.push('      if (await locator.count()) {')
  lines.push("        const href = await locator.getAttribute('href')")
  lines.push('        if (href) return { value: href, selector }')
  lines.push('      }')
  lines.push('    }')
  lines.push("    const a = row.locator('a').first()")
  lines.push('    if (await a.count()) {')
  lines.push("      const href = await a.getAttribute('href')")
  lines.push("      if (href) return { value: href, selector: 'a' }")
  lines.push('    }')
  lines.push('    return { value: null, selector: null }')
  lines.push('  }')
  lines.push('')
  lines.push('  function normalizeUrl(href, base) {')
  lines.push('    try {')
  lines.push('      if (!href) return href')
  lines.push('      if (/^https?:/i.test(href)) return href')
  lines.push('      const b = new URL(base)')
  lines.push('      return new URL(href, b.origin).href')
  lines.push('    } catch {')
  lines.push('      return href')
  lines.push('    }')
  lines.push('  }')
  lines.push('')
  lines.push('  function formatDate(txt) {')
  lines.push('    if (!txt) return null')
  lines.push('    let t = String(txt)')
  lines.push('      .replace(/[\u00A0\t\r\n]+/g, " ")')
  lines.push('      .replace(/[\\.\\/]/g, "-")')
  lines.push('      .replace(/[년]/g, "-")')
  lines.push('      .replace(/[월]/g, "-")')
  lines.push('      .replace(/[일]/g, "")')
  lines.push('      .replace(/\s+/g, " ")')
  lines.push('      .trim()')

  lines.push('    // Drop trailing time or extra tokens after the date portion')
  lines.push('    t = t.split(" ")[0]')

  lines.push('    // YYYY-MM-DD')
  lines.push('    const full = t.match(/(\\d{4})[-](\\d{1,2})[-](\\d{1,2})/')
  lines.push('    if (full) {')
  lines.push('      const y = full[1]')
  lines.push('      const mm = ("0" + full[2]).slice(-2)')
  lines.push('      const dd = ("0" + full[3]).slice(-2)')
  lines.push('      return `${y}-${mm}-${dd}`')
  lines.push('    }')

  lines.push('    // YY-MM-DD -> assume 2000s')
  lines.push('    const short = t.match(/(\\d{2})[-](\\d{1,2})[-](\\d{1,2})/')
  lines.push('    if (short) {')
  lines.push('      const yy = parseInt(short[1], 10)')
  lines.push('      const y = yy >= 80 ? 1900 + yy : 2000 + yy')
  lines.push('      const mm = ("0" + short[2]).slice(-2)')
  lines.push('      const dd = ("0" + short[3]).slice(-2)')
  lines.push('      return `${y}-${mm}-${dd}`')
  lines.push('    }')

  lines.push('    return t')
  lines.push('  }')
  lines.push('')
  lines.push('  function cleanTitle(s) {')
  lines.push("    return (s || '').replace(/[\\\\s\\\\u00A0]+/g, ' ').trim()")
  lines.push('  }')
  lines.push('')
  lines.push('  // Pagination loop: iterate up to maxPages')
  lines.push('  for (let pageNum = 0; pageNum < maxPages; pageNum++) {')
  lines.push('    if (jobs.length >= maxItems) {')
  lines.push("      console.log('[INFO] reached maxItems, stopping pagination')")
  lines.push('      break')
  lines.push('    }')
  lines.push('')
  lines.push("    console.log('[INFO] page', pageNum + 1, 'of', maxPages)")
  lines.push('')
  lines.push('    let rows = []')
  lines.push('    for (const sel of candidates) {')
  lines.push('      rows = await page.locator(sel).all()')
  lines.push('      if (rows.length > 0) {')
  lines.push("        console.log('[INFO] row selector matched:', sel, rows.length)")
  lines.push('        break')
  lines.push('      }')
  lines.push('    }')
  lines.push('')
  lines.push('    if (rows.length === 0) {')
  lines.push("      console.warn('[WARN] no rows found on page', pageNum + 1)")
  lines.push('      break')
  lines.push('    }')
  lines.push('')
  lines.push('    const remaining = Math.max(0, maxItems - jobs.length)')
  lines.push('    const maxCount = Math.min(rows.length, config.crawlBatchSize || 10, remaining)')
  lines.push('    for (let i = 0; i < maxCount; i++) {')
  lines.push('      try {')
  lines.push('        const row = rows[i]')
  lines.push('')
  lines.push('        const titleResult = await firstMatchingText(row, titleSelectors)')
  lines.push('        const linkResult = await firstMatchingHref(row, linkSelectors)')
  lines.push('        if (!titleResult.value || !linkResult.value) continue')
  lines.push('')
  lines.push("        // Skip notice/sticky rows if detectable")
  lines.push("        try {")
  lines.push("          const cls = await row.getAttribute ? await row.getAttribute('class') : null")
  lines.push("          const isNotice = (cls && /notice|sticky|top|pin/i.test(cls)) || /notice/i.test(titleResult.value)")
  lines.push("          if (isNotice) continue")
  lines.push("        } catch { /* ignore */ }")
  lines.push('')
  lines.push('        const dateResult = await firstMatchingText(row, dateSelectors)')
  lines.push('        const attachmentResult = await firstMatchingHref(row, attachmentSelectors)')
  lines.push('')
  lines.push('        const finalUrl = normalizeUrl(linkResult.value, target)')
  lines.push('        if (seen.has(finalUrl)) continue')
  lines.push('        seen.add(finalUrl)')
  lines.push('')
  lines.push('        jobs.push({')
  lines.push('          title: cleanTitle(titleResult.value),')
  lines.push('          url: finalUrl,')
  lines.push('          organization: config.name,')
  lines.push("          location: config.location ?? 'unknown',")
  lines.push("          postedDate: formatDate(dateResult.value) ?? new Date().toISOString().split('T')[0],")
  lines.push("          detailContent: '',")
  lines.push('          attachmentUrl: attachmentResult.value ? normalizeUrl(attachmentResult.value, target) : null,')
  lines.push('        })')
  lines.push('      } catch (rowErr) {')
  lines.push("        console.warn('[WARN] row error:', rowErr instanceof Error ? rowErr.message : rowErr)")
  lines.push('      }')
  lines.push('    }')
  lines.push('')
  lines.push('    // After first page, try to navigate to next page if maxPages > 1')
  lines.push('    if (pageNum + 1 < maxPages && jobs.length < maxItems) {')
  lines.push('      let nextFound = false')
  lines.push('      try {')
  lines.push('        for (const psel of paginationSelectors) {')
  lines.push('          const btn = page.locator(psel).first()')
  lines.push('          if (await btn.count()) {')
  lines.push("            console.log('[INFO] clicking next page via:', psel)")
  lines.push('            await btn.click()')
  lines.push('            await page.waitForTimeout(1500)')
  lines.push('            nextFound = true')
  lines.push('            break')
  lines.push('          }')
  lines.push('        }')
  lines.push('      } catch (navErr) {')
  lines.push("        console.warn('[WARN] pagination navigation error:', navErr instanceof Error ? navErr.message : navErr)")
  lines.push('      }')
  lines.push('      if (!nextFound) {')
  lines.push("        console.log('[INFO] no next page found, stopping pagination')")
  lines.push('        break')
  lines.push('      }')
  lines.push('    }')
  lines.push('  }')
  lines.push('')
  lines.push("  console.log('[INFO] collected', jobs.length, 'items from', Math.min(Math.ceil(jobs.length / (config.crawlBatchSize || 10)), maxPages), 'pages')")
  lines.push('  return jobs')
  lines.push('}')
  return lines.join('\n')
}

// Placeholder exports to ease future incremental updates if imported elsewhere.
export type SandboxResult = { ok: boolean; diagnostics: string[]; durationMs: number }
export async function analyzeBoard(_boardUrl: string): Promise<{ rowSelectors: string[] }> {
  return { rowSelectors: [] }
}

